https://github.com/donnemartin/system-design-primer#system-design-topics-start-here

Scalability
    - Vertical scaling
    - Horizontal scaling
    - Caching
    - Load balancing
    - Database replication
    - Database partitioning
Topics covered:
    Clones
    Databases
    - MySQL, SQL -
        - master-slave replication (read from slaves, write to master)
        - Needs to start introduce sharding
        - Joins are expensive
    - Change from SQL to NoSQL
        - Performance increases since no joins required 
        - Soon getting data will be slow and you need to introduce Caching
    Caches
        - in memory cache - Memcached or Redis
        - Cache - simple key-value store 
        - resides as buffering layer between application and data storage
        - Cache is lighting-fast so you should check before going to Database
        Patterns of Caching Data
            - Cached Database Queries
                - Saving queries result into cache
                - Problem: When a piece of data changes (table cell) you will need to delete all cache queries that include that table cell.
            - Cached Objects
                - Saving instance as objects makes it easy to get back and delete from cache
    Asynchronism
        - The frontend of your website sends a job onto a job queue and immediately signals back to the user: your job is in work, please continue to the browse the page. 
        - The job queue is constantly checked by a bunch of workers for new jobs. If there is a new job then the worker does the job and after some minutes sends a signal that the job was done. 
        - RabbitMQ
            -one of many systems which help to implement async processing

Performance vs Scalability

A service is scalable if it results in increased performance in a manner proportional to resources added. Generally, increasing performance means serving more units of work, but it can also be to handle larger units of work, such as when datasets grow.

Another way to look at performance vs scalability:

If you have a performance problem, your system is slow for a single user.
If you have a scalability problem, your system is fast for a single user but slow under heavy load.

Latency vs Throughput
Latency is the time to perform some action or to produce some result.

Throughput is the number of such actions or results per unit of time.

Generally, you should aim for maximal throughput with acceptable latency.

Availability vs consistency
CAP Theorem
In a distributed computer system, you can only support two of the following guarantees:

Consistency - Every read receives the most recent write or an error
Availability - Every request receives a response, without guarantee that it contains the most recent version of the information
Partition Tolerance - The system continues to operate despite arbitrary partitioning due to network failures
Networks aren't reliable, so you'll need to support partition tolerance. You'll need to make a software tradeoff between consistency and availability.

CP - consistency and partition tolerance
Waiting for a response from the partitioned node might result in a timeout error. CP is a good choice if your business needs require atomic reads and writes.

AP - availability and partition tolerance
Responses return the most recent version of the data available on a node, which might not be the latest. Writes might take some time to propagate when the partition is resolved.

AP is a good choice if the business needs allow for eventual consistency or when the system needs to continue working despite external errors.


Consistency patterns
With multiple copies of the same data, we are faced with options on how to synchronize them so clients have a consistent view of the data. Recall the definition of consistency from the CAP theorem - Every read receives the most recent write or an error.

Weak consistency
After a write, reads may or may not see it. A best effort approach is taken.

This approach is seen in systems such as memcached. Weak consistency works well in real time use cases such as VoIP, video chat, and realtime multiplayer games. For example, if you are on a phone call and lose reception for a few seconds, when you regain connection you do not hear what was spoken during connection loss.

Eventual consistency
After a write, reads will eventually see it (typically within milliseconds). Data is replicated asynchronously.

This approach is seen in systems such as DNS and email. Eventual consistency works well in highly available systems.

Strong consistency
After a write, reads will see it. Data is replicated synchronously.

This approach is seen in file systems and RDBMSes. Strong consistency works well in systems that need transactions.